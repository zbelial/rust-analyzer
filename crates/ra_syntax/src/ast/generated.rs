// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.

#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::{
    SyntaxNode, SyntaxKind::{self, *},
    ast::{self, AstNode},
};

// Alias
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Alias {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Alias {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ALIAS => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Alias { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::NameOwner for Alias {}
impl Alias {}

// ArgList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARG_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArgList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArgList {
    pub fn args(&self) -> impl Iterator<Item = Expr> {
        super::children(self)
    }
}

// ArrayExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        super::children(self)
    }
}

// ArrayType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// AssocTypeArg
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocTypeArg {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for AssocTypeArg {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ASSOC_TYPE_ARG => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(AssocTypeArg { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl AssocTypeArg {
    pub fn name_ref(&self) -> Option<NameRef> {
        super::child_opt(self)
    }

    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// Attr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Attr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ATTR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Attr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Attr {
    pub fn value(&self) -> Option<TokenTree> {
        super::child_opt(self)
    }
}

// AwaitExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for AwaitExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            AWAIT_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(AwaitExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl AwaitExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// BinExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BinExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BinExpr {}

// BindPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BindPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BindPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIND_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BindPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::NameOwner for BindPat {}
impl BindPat {
    pub fn pat(&self) -> Option<Pat> {
        super::child_opt(self)
    }
}

// Block
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Block {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Block { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::AttrsOwner for Block {}
impl Block {
    pub fn statements(&self) -> impl Iterator<Item = Stmt> {
        super::children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// BlockExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BlockExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BlockExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BlockExpr {
    pub fn block(&self) -> Option<Block> {
        super::child_opt(self)
    }
}

// BreakExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BreakExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BREAK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BreakExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BreakExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// CallExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CALL_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CallExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::ArgListOwner for CallExpr {}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// CastExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CastExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CAST_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CastExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl CastExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }

    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// Condition
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Condition {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Condition {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONDITION => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Condition { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Condition {
    pub fn pat(&self) -> Option<Pat> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// ConstDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ConstDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONST_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ConstDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for ConstDef {}
impl ast::NameOwner for ConstDef {}
impl ast::TypeParamsOwner for ConstDef {}
impl ast::AttrsOwner for ConstDef {}
impl ast::DocCommentsOwner for ConstDef {}
impl ast::TypeAscriptionOwner for ConstDef {}
impl ConstDef {
    pub fn body(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// ContinueExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ContinueExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONTINUE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ContinueExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ContinueExpr {}

// DynTraitType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DynTraitType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for DynTraitType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            DYN_TRAIT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(DynTraitType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TypeBoundsOwner for DynTraitType {}
impl DynTraitType {}

// EnumDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for EnumDef {}
impl ast::NameOwner for EnumDef {}
impl ast::TypeParamsOwner for EnumDef {}
impl ast::AttrsOwner for EnumDef {}
impl ast::DocCommentsOwner for EnumDef {}
impl EnumDef {
    pub fn variant_list(&self) -> Option<EnumVariantList> {
        super::child_opt(self)
    }
}

// EnumVariant
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariant {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariant { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::NameOwner for EnumVariant {}
impl ast::DocCommentsOwner for EnumVariant {}
impl ast::AttrsOwner for EnumVariant {}
impl EnumVariant {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// EnumVariantList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariantList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariantList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl EnumVariantList {
    pub fn variants(&self) -> impl Iterator<Item = EnumVariant> {
        super::children(self)
    }
}

// Expr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | STRUCT_LIT | CALL_EXPR | INDEX_EXPR | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | TRY_BLOCK_EXPR | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Expr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ExprKind {
    TupleExpr(TupleExpr),
    ArrayExpr(ArrayExpr),
    ParenExpr(ParenExpr),
    PathExpr(PathExpr),
    LambdaExpr(LambdaExpr),
    IfExpr(IfExpr),
    LoopExpr(LoopExpr),
    ForExpr(ForExpr),
    WhileExpr(WhileExpr),
    ContinueExpr(ContinueExpr),
    BreakExpr(BreakExpr),
    Label(Label),
    BlockExpr(BlockExpr),
    ReturnExpr(ReturnExpr),
    MatchExpr(MatchExpr),
    StructLit(StructLit),
    CallExpr(CallExpr),
    IndexExpr(IndexExpr),
    MethodCallExpr(MethodCallExpr),
    FieldExpr(FieldExpr),
    AwaitExpr(AwaitExpr),
    TryExpr(TryExpr),
    TryBlockExpr(TryBlockExpr),
    CastExpr(CastExpr),
    RefExpr(RefExpr),
    PrefixExpr(PrefixExpr),
    RangeExpr(RangeExpr),
    BinExpr(BinExpr),
    Literal(Literal),
    MacroCall(MacroCall),
}
impl From<TupleExpr> for Expr {
    fn from(n: TupleExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ArrayExpr> for Expr {
    fn from(n: ArrayExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ParenExpr> for Expr {
    fn from(n: ParenExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<PathExpr> for Expr {
    fn from(n: PathExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<LambdaExpr> for Expr {
    fn from(n: LambdaExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<IfExpr> for Expr {
    fn from(n: IfExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<LoopExpr> for Expr {
    fn from(n: LoopExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ForExpr> for Expr {
    fn from(n: ForExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<WhileExpr> for Expr {
    fn from(n: WhileExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ContinueExpr> for Expr {
    fn from(n: ContinueExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<BreakExpr> for Expr {
    fn from(n: BreakExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<Label> for Expr {
    fn from(n: Label) -> Expr { Expr { syntax: n.syntax } }
}
impl From<BlockExpr> for Expr {
    fn from(n: BlockExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<ReturnExpr> for Expr {
    fn from(n: ReturnExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<MatchExpr> for Expr {
    fn from(n: MatchExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<StructLit> for Expr {
    fn from(n: StructLit) -> Expr { Expr { syntax: n.syntax } }
}
impl From<CallExpr> for Expr {
    fn from(n: CallExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<IndexExpr> for Expr {
    fn from(n: IndexExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<MethodCallExpr> for Expr {
    fn from(n: MethodCallExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<FieldExpr> for Expr {
    fn from(n: FieldExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<AwaitExpr> for Expr {
    fn from(n: AwaitExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<TryExpr> for Expr {
    fn from(n: TryExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<TryBlockExpr> for Expr {
    fn from(n: TryBlockExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<CastExpr> for Expr {
    fn from(n: CastExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<RefExpr> for Expr {
    fn from(n: RefExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<PrefixExpr> for Expr {
    fn from(n: PrefixExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<RangeExpr> for Expr {
    fn from(n: RangeExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<BinExpr> for Expr {
    fn from(n: BinExpr) -> Expr { Expr { syntax: n.syntax } }
}
impl From<Literal> for Expr {
    fn from(n: Literal) -> Expr { Expr { syntax: n.syntax } }
}
impl From<MacroCall> for Expr {
    fn from(n: MacroCall) -> Expr { Expr { syntax: n.syntax } }
}
impl Expr {
    pub fn kind(&self) -> ExprKind {
        match self.syntax.kind() {
            TUPLE_EXPR => ExprKind::TupleExpr(TupleExpr::cast(self.syntax.clone()).unwrap()),
            ARRAY_EXPR => ExprKind::ArrayExpr(ArrayExpr::cast(self.syntax.clone()).unwrap()),
            PAREN_EXPR => ExprKind::ParenExpr(ParenExpr::cast(self.syntax.clone()).unwrap()),
            PATH_EXPR => ExprKind::PathExpr(PathExpr::cast(self.syntax.clone()).unwrap()),
            LAMBDA_EXPR => ExprKind::LambdaExpr(LambdaExpr::cast(self.syntax.clone()).unwrap()),
            IF_EXPR => ExprKind::IfExpr(IfExpr::cast(self.syntax.clone()).unwrap()),
            LOOP_EXPR => ExprKind::LoopExpr(LoopExpr::cast(self.syntax.clone()).unwrap()),
            FOR_EXPR => ExprKind::ForExpr(ForExpr::cast(self.syntax.clone()).unwrap()),
            WHILE_EXPR => ExprKind::WhileExpr(WhileExpr::cast(self.syntax.clone()).unwrap()),
            CONTINUE_EXPR => ExprKind::ContinueExpr(ContinueExpr::cast(self.syntax.clone()).unwrap()),
            BREAK_EXPR => ExprKind::BreakExpr(BreakExpr::cast(self.syntax.clone()).unwrap()),
            LABEL => ExprKind::Label(Label::cast(self.syntax.clone()).unwrap()),
            BLOCK_EXPR => ExprKind::BlockExpr(BlockExpr::cast(self.syntax.clone()).unwrap()),
            RETURN_EXPR => ExprKind::ReturnExpr(ReturnExpr::cast(self.syntax.clone()).unwrap()),
            MATCH_EXPR => ExprKind::MatchExpr(MatchExpr::cast(self.syntax.clone()).unwrap()),
            STRUCT_LIT => ExprKind::StructLit(StructLit::cast(self.syntax.clone()).unwrap()),
            CALL_EXPR => ExprKind::CallExpr(CallExpr::cast(self.syntax.clone()).unwrap()),
            INDEX_EXPR => ExprKind::IndexExpr(IndexExpr::cast(self.syntax.clone()).unwrap()),
            METHOD_CALL_EXPR => ExprKind::MethodCallExpr(MethodCallExpr::cast(self.syntax.clone()).unwrap()),
            FIELD_EXPR => ExprKind::FieldExpr(FieldExpr::cast(self.syntax.clone()).unwrap()),
            AWAIT_EXPR => ExprKind::AwaitExpr(AwaitExpr::cast(self.syntax.clone()).unwrap()),
            TRY_EXPR => ExprKind::TryExpr(TryExpr::cast(self.syntax.clone()).unwrap()),
            TRY_BLOCK_EXPR => ExprKind::TryBlockExpr(TryBlockExpr::cast(self.syntax.clone()).unwrap()),
            CAST_EXPR => ExprKind::CastExpr(CastExpr::cast(self.syntax.clone()).unwrap()),
            REF_EXPR => ExprKind::RefExpr(RefExpr::cast(self.syntax.clone()).unwrap()),
            PREFIX_EXPR => ExprKind::PrefixExpr(PrefixExpr::cast(self.syntax.clone()).unwrap()),
            RANGE_EXPR => ExprKind::RangeExpr(RangeExpr::cast(self.syntax.clone()).unwrap()),
            BIN_EXPR => ExprKind::BinExpr(BinExpr::cast(self.syntax.clone()).unwrap()),
            LITERAL => ExprKind::Literal(Literal::cast(self.syntax.clone()).unwrap()),
            MACRO_CALL => ExprKind::MacroCall(MacroCall::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Expr {}

// ExprStmt
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EXPR_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ExprStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// ExternCrateItem
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternCrateItem {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ExternCrateItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EXTERN_CRATE_ITEM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ExternCrateItem { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ExternCrateItem {
    pub fn name_ref(&self) -> Option<NameRef> {
        super::child_opt(self)
    }

    pub fn alias(&self) -> Option<Alias> {
        super::child_opt(self)
    }
}

// FieldExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FieldExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FIELD_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FieldExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl FieldExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }

    pub fn name_ref(&self) -> Option<NameRef> {
        super::child_opt(self)
    }
}

// FieldPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FieldPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FIELD_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FieldPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::NameOwner for FieldPat {}
impl FieldPat {
    pub fn pat(&self) -> Option<Pat> {
        super::child_opt(self)
    }
}

// FieldPatList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldPatList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FieldPatList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FIELD_PAT_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FieldPatList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl FieldPatList {
    pub fn field_pats(&self) -> impl Iterator<Item = FieldPat> {
        super::children(self)
    }

    pub fn bind_pats(&self) -> impl Iterator<Item = BindPat> {
        super::children(self)
    }
}

// FnDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for FnDef {}
impl ast::NameOwner for FnDef {}
impl ast::TypeParamsOwner for FnDef {}
impl ast::AttrsOwner for FnDef {}
impl ast::DocCommentsOwner for FnDef {}
impl FnDef {
    pub fn param_list(&self) -> Option<ParamList> {
        super::child_opt(self)
    }

    pub fn body(&self) -> Option<Block> {
        super::child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        super::child_opt(self)
    }
}

// FnPointerType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnPointerType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnPointerType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_POINTER_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnPointerType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl FnPointerType {
    pub fn param_list(&self) -> Option<ParamList> {
        super::child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        super::child_opt(self)
    }
}

// ForExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ForExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FOR_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ForExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::LoopBodyOwner for ForExpr {}
impl ForExpr {
    pub fn pat(&self) -> Option<Pat> {
        super::child_opt(self)
    }

    pub fn iterable(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// ForType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ForType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FOR_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ForType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ForType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// IfExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IfExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IF_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IfExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IfExpr {
    pub fn condition(&self) -> Option<Condition> {
        super::child_opt(self)
    }
}

// ImplBlock
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplBlock {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ImplBlock {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IMPL_BLOCK => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ImplBlock { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TypeParamsOwner for ImplBlock {}
impl ast::AttrsOwner for ImplBlock {}
impl ImplBlock {
    pub fn item_list(&self) -> Option<ItemList> {
        super::child_opt(self)
    }
}

// ImplItem
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplItem {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ImplItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | FN_DEF | TYPE_ALIAS_DEF | CONST_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ImplItem { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ImplItemKind {
    FnDef(FnDef),
    TypeAliasDef(TypeAliasDef),
    ConstDef(ConstDef),
}
impl From<FnDef> for ImplItem {
    fn from(n: FnDef) -> ImplItem { ImplItem { syntax: n.syntax } }
}
impl From<TypeAliasDef> for ImplItem {
    fn from(n: TypeAliasDef) -> ImplItem { ImplItem { syntax: n.syntax } }
}
impl From<ConstDef> for ImplItem {
    fn from(n: ConstDef) -> ImplItem { ImplItem { syntax: n.syntax } }
}
impl ImplItem {
    pub fn kind(&self) -> ImplItemKind {
        match self.syntax.kind() {
            FN_DEF => ImplItemKind::FnDef(FnDef::cast(self.syntax.clone()).unwrap()),
            TYPE_ALIAS_DEF => ImplItemKind::TypeAliasDef(TypeAliasDef::cast(self.syntax.clone()).unwrap()),
            CONST_DEF => ImplItemKind::ConstDef(ConstDef::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ImplItem {}

// ImplTraitType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplTraitType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ImplTraitType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IMPL_TRAIT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ImplTraitType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TypeBoundsOwner for ImplTraitType {}
impl ImplTraitType {}

// IndexExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IndexExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            INDEX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IndexExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IndexExpr {}

// ItemList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ItemList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ITEM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ItemList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::FnDefOwner for ItemList {}
impl ast::ModuleItemOwner for ItemList {}
impl ItemList {
    pub fn impl_items(&self) -> impl Iterator<Item = ImplItem> {
        super::children(self)
    }
}

// Label
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Label {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Label {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LABEL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Label { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Label {}

// LambdaExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LambdaExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LAMBDA_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LambdaExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl LambdaExpr {
    pub fn param_list(&self) -> Option<ParamList> {
        super::child_opt(self)
    }

    pub fn body(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// LetStmt
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LetStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LetStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TypeAscriptionOwner for LetStmt {}
impl LetStmt {
    pub fn pat(&self) -> Option<Pat> {
        super::child_opt(self)
    }

    pub fn initializer(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// LifetimeArg
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeArg {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LifetimeArg {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LIFETIME_ARG => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LifetimeArg { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl LifetimeArg {}

// LifetimeParam
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeParam {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LifetimeParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LIFETIME_PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LifetimeParam { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::AttrsOwner for LifetimeParam {}
impl LifetimeParam {}

// Literal
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Literal { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Literal {}

// LiteralPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LiteralPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LiteralPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl LiteralPat {
    pub fn literal(&self) -> Option<Literal> {
        super::child_opt(self)
    }
}

// LoopExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LoopExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LOOP_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LoopExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::LoopBodyOwner for LoopExpr {}
impl LoopExpr {}

// MacroCall
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroCall {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MacroCall {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MACRO_CALL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MacroCall { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::NameOwner for MacroCall {}
impl ast::AttrsOwner for MacroCall {}
impl ast::DocCommentsOwner for MacroCall {}
impl MacroCall {
    pub fn token_tree(&self) -> Option<TokenTree> {
        super::child_opt(self)
    }

    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }
}

// MacroItems
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroItems {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MacroItems {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MACRO_ITEMS => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MacroItems { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::ModuleItemOwner for MacroItems {}
impl ast::FnDefOwner for MacroItems {}
impl MacroItems {}

// MacroStmts
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroStmts {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MacroStmts {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MACRO_STMTS => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MacroStmts { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MacroStmts {
    pub fn statements(&self) -> impl Iterator<Item = Stmt> {
        super::children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// MatchArm
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArm { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::AttrsOwner for MatchArm {}
impl MatchArm {
    pub fn pats(&self) -> impl Iterator<Item = Pat> {
        super::children(self)
    }

    pub fn guard(&self) -> Option<MatchGuard> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// MatchArmList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArmList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArmList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::AttrsOwner for MatchArmList {}
impl MatchArmList {
    pub fn arms(&self) -> impl Iterator<Item = MatchArm> {
        super::children(self)
    }
}

// MatchExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }

    pub fn match_arm_list(&self) -> Option<MatchArmList> {
        super::child_opt(self)
    }
}

// MatchGuard
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchGuard {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchGuard {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_GUARD => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchGuard { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchGuard {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// MethodCallExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MethodCallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            METHOD_CALL_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MethodCallExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::ArgListOwner for MethodCallExpr {}
impl MethodCallExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }

    pub fn name_ref(&self) -> Option<NameRef> {
        super::child_opt(self)
    }

    pub fn type_arg_list(&self) -> Option<TypeArgList> {
        super::child_opt(self)
    }
}

// Module
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Module {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MODULE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Module { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for Module {}
impl ast::NameOwner for Module {}
impl ast::AttrsOwner for Module {}
impl ast::DocCommentsOwner for Module {}
impl Module {
    pub fn item_list(&self) -> Option<ItemList> {
        super::child_opt(self)
    }
}

// ModuleItem
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleItem {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ModuleItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_BLOCK | USE_ITEM | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ModuleItem { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ModuleItemKind {
    StructDef(StructDef),
    EnumDef(EnumDef),
    FnDef(FnDef),
    TraitDef(TraitDef),
    TypeAliasDef(TypeAliasDef),
    ImplBlock(ImplBlock),
    UseItem(UseItem),
    ExternCrateItem(ExternCrateItem),
    ConstDef(ConstDef),
    StaticDef(StaticDef),
    Module(Module),
}
impl From<StructDef> for ModuleItem {
    fn from(n: StructDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<EnumDef> for ModuleItem {
    fn from(n: EnumDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<FnDef> for ModuleItem {
    fn from(n: FnDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<TraitDef> for ModuleItem {
    fn from(n: TraitDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<TypeAliasDef> for ModuleItem {
    fn from(n: TypeAliasDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<ImplBlock> for ModuleItem {
    fn from(n: ImplBlock) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<UseItem> for ModuleItem {
    fn from(n: UseItem) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<ExternCrateItem> for ModuleItem {
    fn from(n: ExternCrateItem) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<ConstDef> for ModuleItem {
    fn from(n: ConstDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<StaticDef> for ModuleItem {
    fn from(n: StaticDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl From<Module> for ModuleItem {
    fn from(n: Module) -> ModuleItem { ModuleItem { syntax: n.syntax } }
}
impl ModuleItem {
    pub fn kind(&self) -> ModuleItemKind {
        match self.syntax.kind() {
            STRUCT_DEF => ModuleItemKind::StructDef(StructDef::cast(self.syntax.clone()).unwrap()),
            ENUM_DEF => ModuleItemKind::EnumDef(EnumDef::cast(self.syntax.clone()).unwrap()),
            FN_DEF => ModuleItemKind::FnDef(FnDef::cast(self.syntax.clone()).unwrap()),
            TRAIT_DEF => ModuleItemKind::TraitDef(TraitDef::cast(self.syntax.clone()).unwrap()),
            TYPE_ALIAS_DEF => ModuleItemKind::TypeAliasDef(TypeAliasDef::cast(self.syntax.clone()).unwrap()),
            IMPL_BLOCK => ModuleItemKind::ImplBlock(ImplBlock::cast(self.syntax.clone()).unwrap()),
            USE_ITEM => ModuleItemKind::UseItem(UseItem::cast(self.syntax.clone()).unwrap()),
            EXTERN_CRATE_ITEM => ModuleItemKind::ExternCrateItem(ExternCrateItem::cast(self.syntax.clone()).unwrap()),
            CONST_DEF => ModuleItemKind::ConstDef(ConstDef::cast(self.syntax.clone()).unwrap()),
            STATIC_DEF => ModuleItemKind::StaticDef(StaticDef::cast(self.syntax.clone()).unwrap()),
            MODULE => ModuleItemKind::Module(Module::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ModuleItem {}

// Name
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Name { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Name {}

// NameRef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NameRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME_REF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NameRef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NameRef {}

// NamedField
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedField {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedField {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedField { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedField {
    pub fn name_ref(&self) -> Option<NameRef> {
        super::child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// NamedFieldDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for NamedFieldDef {}
impl ast::NameOwner for NamedFieldDef {}
impl ast::AttrsOwner for NamedFieldDef {}
impl ast::DocCommentsOwner for NamedFieldDef {}
impl ast::TypeAscriptionOwner for NamedFieldDef {}
impl NamedFieldDef {}

// NamedFieldDefList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDefList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDefList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDefList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldDefList {
    pub fn fields(&self) -> impl Iterator<Item = NamedFieldDef> {
        super::children(self)
    }
}

// NamedFieldList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldList {
    pub fn fields(&self) -> impl Iterator<Item = NamedField> {
        super::children(self)
    }

    pub fn spread(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// NeverType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NeverType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NeverType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NEVER_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NeverType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NeverType {}

// NominalDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NominalDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NominalDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | STRUCT_DEF | ENUM_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NominalDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NominalDefKind {
    StructDef(StructDef),
    EnumDef(EnumDef),
}
impl From<StructDef> for NominalDef {
    fn from(n: StructDef) -> NominalDef { NominalDef { syntax: n.syntax } }
}
impl From<EnumDef> for NominalDef {
    fn from(n: EnumDef) -> NominalDef { NominalDef { syntax: n.syntax } }
}
impl NominalDef {
    pub fn kind(&self) -> NominalDefKind {
        match self.syntax.kind() {
            STRUCT_DEF => NominalDefKind::StructDef(StructDef::cast(self.syntax.clone()).unwrap()),
            ENUM_DEF => NominalDefKind::EnumDef(EnumDef::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl ast::NameOwner for NominalDef {}
impl ast::TypeParamsOwner for NominalDef {}
impl ast::AttrsOwner for NominalDef {}
impl NominalDef {}

// Param
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Param {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Param { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TypeAscriptionOwner for Param {}
impl ast::AttrsOwner for Param {}
impl Param {
    pub fn pat(&self) -> Option<Pat> {
        super::child_opt(self)
    }
}

// ParamList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParamList {
    pub fn params(&self) -> impl Iterator<Item = Param> {
        super::children(self)
    }

    pub fn self_param(&self) -> Option<SelfParam> {
        super::child_opt(self)
    }
}

// ParenExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParenExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// ParenType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParenType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// Pat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Pat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Pat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | REF_PAT | BIND_PAT | PLACEHOLDER_PAT | PATH_PAT | STRUCT_PAT | TUPLE_STRUCT_PAT | TUPLE_PAT | SLICE_PAT | RANGE_PAT | LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Pat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PatKind {
    RefPat(RefPat),
    BindPat(BindPat),
    PlaceholderPat(PlaceholderPat),
    PathPat(PathPat),
    StructPat(StructPat),
    TupleStructPat(TupleStructPat),
    TuplePat(TuplePat),
    SlicePat(SlicePat),
    RangePat(RangePat),
    LiteralPat(LiteralPat),
}
impl From<RefPat> for Pat {
    fn from(n: RefPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<BindPat> for Pat {
    fn from(n: BindPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<PlaceholderPat> for Pat {
    fn from(n: PlaceholderPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<PathPat> for Pat {
    fn from(n: PathPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<StructPat> for Pat {
    fn from(n: StructPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<TupleStructPat> for Pat {
    fn from(n: TupleStructPat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<TuplePat> for Pat {
    fn from(n: TuplePat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<SlicePat> for Pat {
    fn from(n: SlicePat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<RangePat> for Pat {
    fn from(n: RangePat) -> Pat { Pat { syntax: n.syntax } }
}
impl From<LiteralPat> for Pat {
    fn from(n: LiteralPat) -> Pat { Pat { syntax: n.syntax } }
}
impl Pat {
    pub fn kind(&self) -> PatKind {
        match self.syntax.kind() {
            REF_PAT => PatKind::RefPat(RefPat::cast(self.syntax.clone()).unwrap()),
            BIND_PAT => PatKind::BindPat(BindPat::cast(self.syntax.clone()).unwrap()),
            PLACEHOLDER_PAT => PatKind::PlaceholderPat(PlaceholderPat::cast(self.syntax.clone()).unwrap()),
            PATH_PAT => PatKind::PathPat(PathPat::cast(self.syntax.clone()).unwrap()),
            STRUCT_PAT => PatKind::StructPat(StructPat::cast(self.syntax.clone()).unwrap()),
            TUPLE_STRUCT_PAT => PatKind::TupleStructPat(TupleStructPat::cast(self.syntax.clone()).unwrap()),
            TUPLE_PAT => PatKind::TuplePat(TuplePat::cast(self.syntax.clone()).unwrap()),
            SLICE_PAT => PatKind::SlicePat(SlicePat::cast(self.syntax.clone()).unwrap()),
            RANGE_PAT => PatKind::RangePat(RangePat::cast(self.syntax.clone()).unwrap()),
            LITERAL_PAT => PatKind::LiteralPat(LiteralPat::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Pat {}

// Path
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Path {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PATH => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Path { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Path {
    pub fn segment(&self) -> Option<PathSegment> {
        super::child_opt(self)
    }

    pub fn qualifier(&self) -> Option<Path> {
        super::child_opt(self)
    }
}

// PathExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PathExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PATH_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PathExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PathExpr {
    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }
}

// PathPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PathPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PATH_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PathPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PathPat {
    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }
}

// PathSegment
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PathSegment {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PATH_SEGMENT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PathSegment { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PathSegment {
    pub fn name_ref(&self) -> Option<NameRef> {
        super::child_opt(self)
    }

    pub fn type_arg_list(&self) -> Option<TypeArgList> {
        super::child_opt(self)
    }
}

// PathType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PathType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PATH_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PathType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PathType {
    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }
}

// PlaceholderPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlaceholderPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PlaceholderPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PLACEHOLDER_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PlaceholderPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PlaceholderPat {}

// PlaceholderType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlaceholderType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PlaceholderType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PLACEHOLDER_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PlaceholderType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PlaceholderType {}

// PointerType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PointerType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PointerType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            POINTER_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PointerType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PointerType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// PosFieldDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PosFieldDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PosFieldDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            POS_FIELD_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PosFieldDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for PosFieldDef {}
impl ast::AttrsOwner for PosFieldDef {}
impl PosFieldDef {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// PosFieldDefList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PosFieldDefList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PosFieldDefList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            POS_FIELD_DEF_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PosFieldDefList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PosFieldDefList {
    pub fn fields(&self) -> impl Iterator<Item = PosFieldDef> {
        super::children(self)
    }
}

// PrefixExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PrefixExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PREFIX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PrefixExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PrefixExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// RangeExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RangeExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RANGE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RangeExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RangeExpr {}

// RangePat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangePat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RangePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RANGE_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RangePat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RangePat {}

// RefExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RefExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            REF_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RefExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RefExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// RefPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RefPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            REF_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RefPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RefPat {
    pub fn pat(&self) -> Option<Pat> {
        super::child_opt(self)
    }
}

// ReferenceType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReferenceType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ReferenceType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            REFERENCE_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ReferenceType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ReferenceType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// RetType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RetType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RET_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RetType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RetType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// ReturnExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ReturnExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RETURN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ReturnExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ReturnExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// SelfParam
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelfParam {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for SelfParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SELF_PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(SelfParam { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TypeAscriptionOwner for SelfParam {}
impl ast::AttrsOwner for SelfParam {}
impl SelfParam {}

// SlicePat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlicePat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for SlicePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SLICE_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(SlicePat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl SlicePat {}

// SliceType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for SliceType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SLICE_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(SliceType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl SliceType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// SourceFile
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SOURCE_FILE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(SourceFile { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::ModuleItemOwner for SourceFile {}
impl ast::FnDefOwner for SourceFile {}
impl SourceFile {
    pub fn modules(&self) -> impl Iterator<Item = Module> {
        super::children(self)
    }
}

// StaticDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StaticDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for StaticDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            STATIC_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(StaticDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for StaticDef {}
impl ast::NameOwner for StaticDef {}
impl ast::TypeParamsOwner for StaticDef {}
impl ast::AttrsOwner for StaticDef {}
impl ast::DocCommentsOwner for StaticDef {}
impl ast::TypeAscriptionOwner for StaticDef {}
impl StaticDef {
    pub fn body(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// Stmt
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Stmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | EXPR_STMT | LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Stmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum StmtKind {
    ExprStmt(ExprStmt),
    LetStmt(LetStmt),
}
impl From<ExprStmt> for Stmt {
    fn from(n: ExprStmt) -> Stmt { Stmt { syntax: n.syntax } }
}
impl From<LetStmt> for Stmt {
    fn from(n: LetStmt) -> Stmt { Stmt { syntax: n.syntax } }
}
impl Stmt {
    pub fn kind(&self) -> StmtKind {
        match self.syntax.kind() {
            EXPR_STMT => StmtKind::ExprStmt(ExprStmt::cast(self.syntax.clone()).unwrap()),
            LET_STMT => StmtKind::LetStmt(LetStmt::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl Stmt {}

// StructDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for StructDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            STRUCT_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(StructDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for StructDef {}
impl ast::NameOwner for StructDef {}
impl ast::TypeParamsOwner for StructDef {}
impl ast::AttrsOwner for StructDef {}
impl ast::DocCommentsOwner for StructDef {}
impl StructDef {}

// StructLit
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructLit {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for StructLit {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            STRUCT_LIT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(StructLit { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl StructLit {
    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }

    pub fn named_field_list(&self) -> Option<NamedFieldList> {
        super::child_opt(self)
    }
}

// StructPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for StructPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            STRUCT_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(StructPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl StructPat {
    pub fn field_pat_list(&self) -> Option<FieldPatList> {
        super::child_opt(self)
    }

    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }
}

// TokenTree
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TokenTree {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TokenTree {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TOKEN_TREE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TokenTree { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TokenTree {}

// TraitDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TraitDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TRAIT_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TraitDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for TraitDef {}
impl ast::NameOwner for TraitDef {}
impl ast::AttrsOwner for TraitDef {}
impl ast::DocCommentsOwner for TraitDef {}
impl ast::TypeParamsOwner for TraitDef {}
impl ast::TypeBoundsOwner for TraitDef {}
impl TraitDef {
    pub fn item_list(&self) -> Option<ItemList> {
        super::child_opt(self)
    }
}

// TryBlockExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryBlockExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TryBlockExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TRY_BLOCK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TryBlockExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TryBlockBodyOwner for TryBlockExpr {}
impl TryBlockExpr {}

// TryExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TRY_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TryExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TryExpr {
    pub fn expr(&self) -> Option<Expr> {
        super::child_opt(self)
    }
}

// TupleExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TupleExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TupleExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TupleExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        super::children(self)
    }
}

// TuplePat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TuplePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TuplePat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TuplePat {
    pub fn args(&self) -> impl Iterator<Item = Pat> {
        super::children(self)
    }
}

// TupleStructPat
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleStructPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TupleStructPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_STRUCT_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TupleStructPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TupleStructPat {
    pub fn args(&self) -> impl Iterator<Item = Pat> {
        super::children(self)
    }

    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }
}

// TupleType
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TupleType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TupleType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TupleType {
    pub fn fields(&self) -> impl Iterator<Item = TypeRef> {
        super::children(self)
    }
}

// TypeAliasDef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAliasDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeAliasDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_ALIAS_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeAliasDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::VisibilityOwner for TypeAliasDef {}
impl ast::NameOwner for TypeAliasDef {}
impl ast::TypeParamsOwner for TypeAliasDef {}
impl ast::AttrsOwner for TypeAliasDef {}
impl ast::DocCommentsOwner for TypeAliasDef {}
impl ast::TypeBoundsOwner for TypeAliasDef {}
impl TypeAliasDef {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// TypeArg
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeArg {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_ARG => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeArg { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeArg {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// TypeArgList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArgList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_ARG_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeArgList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeArgList {
    pub fn type_args(&self) -> impl Iterator<Item = TypeArg> {
        super::children(self)
    }

    pub fn lifetime_args(&self) -> impl Iterator<Item = LifetimeArg> {
        super::children(self)
    }

    pub fn assoc_type_args(&self) -> impl Iterator<Item = AssocTypeArg> {
        super::children(self)
    }
}

// TypeBound
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBound {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeBound {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_BOUND => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeBound { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeBound {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// TypeBoundList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBoundList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeBoundList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_BOUND_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeBoundList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeBoundList {
    pub fn bounds(&self) -> impl Iterator<Item = TypeBound> {
        super::children(self)
    }
}

// TypeParam
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParam { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::NameOwner for TypeParam {}
impl ast::AttrsOwner for TypeParam {}
impl ast::TypeBoundsOwner for TypeParam {}
impl ast::DefaultTypeParamOwner for TypeParam {}
impl TypeParam {}

// TypeParamList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeParamList {
    pub fn type_params(&self) -> impl Iterator<Item = TypeParam> {
        super::children(self)
    }

    pub fn lifetime_params(&self) -> impl Iterator<Item = LifetimeParam> {
        super::children(self)
    }
}

// TypeRef
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeRef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE | SLICE_TYPE | REFERENCE_TYPE | PLACEHOLDER_TYPE | FN_POINTER_TYPE | FOR_TYPE | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeRef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TypeRefKind {
    ParenType(ParenType),
    TupleType(TupleType),
    NeverType(NeverType),
    PathType(PathType),
    PointerType(PointerType),
    ArrayType(ArrayType),
    SliceType(SliceType),
    ReferenceType(ReferenceType),
    PlaceholderType(PlaceholderType),
    FnPointerType(FnPointerType),
    ForType(ForType),
    ImplTraitType(ImplTraitType),
    DynTraitType(DynTraitType),
}
impl From<ParenType> for TypeRef {
    fn from(n: ParenType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<TupleType> for TypeRef {
    fn from(n: TupleType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<NeverType> for TypeRef {
    fn from(n: NeverType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<PathType> for TypeRef {
    fn from(n: PathType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<PointerType> for TypeRef {
    fn from(n: PointerType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<ArrayType> for TypeRef {
    fn from(n: ArrayType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<SliceType> for TypeRef {
    fn from(n: SliceType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<ReferenceType> for TypeRef {
    fn from(n: ReferenceType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<PlaceholderType> for TypeRef {
    fn from(n: PlaceholderType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<FnPointerType> for TypeRef {
    fn from(n: FnPointerType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<ForType> for TypeRef {
    fn from(n: ForType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<ImplTraitType> for TypeRef {
    fn from(n: ImplTraitType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl From<DynTraitType> for TypeRef {
    fn from(n: DynTraitType) -> TypeRef { TypeRef { syntax: n.syntax } }
}
impl TypeRef {
    pub fn kind(&self) -> TypeRefKind {
        match self.syntax.kind() {
            PAREN_TYPE => TypeRefKind::ParenType(ParenType::cast(self.syntax.clone()).unwrap()),
            TUPLE_TYPE => TypeRefKind::TupleType(TupleType::cast(self.syntax.clone()).unwrap()),
            NEVER_TYPE => TypeRefKind::NeverType(NeverType::cast(self.syntax.clone()).unwrap()),
            PATH_TYPE => TypeRefKind::PathType(PathType::cast(self.syntax.clone()).unwrap()),
            POINTER_TYPE => TypeRefKind::PointerType(PointerType::cast(self.syntax.clone()).unwrap()),
            ARRAY_TYPE => TypeRefKind::ArrayType(ArrayType::cast(self.syntax.clone()).unwrap()),
            SLICE_TYPE => TypeRefKind::SliceType(SliceType::cast(self.syntax.clone()).unwrap()),
            REFERENCE_TYPE => TypeRefKind::ReferenceType(ReferenceType::cast(self.syntax.clone()).unwrap()),
            PLACEHOLDER_TYPE => TypeRefKind::PlaceholderType(PlaceholderType::cast(self.syntax.clone()).unwrap()),
            FN_POINTER_TYPE => TypeRefKind::FnPointerType(FnPointerType::cast(self.syntax.clone()).unwrap()),
            FOR_TYPE => TypeRefKind::ForType(ForType::cast(self.syntax.clone()).unwrap()),
            IMPL_TRAIT_TYPE => TypeRefKind::ImplTraitType(ImplTraitType::cast(self.syntax.clone()).unwrap()),
            DYN_TRAIT_TYPE => TypeRefKind::DynTraitType(DynTraitType::cast(self.syntax.clone()).unwrap()),
            _ => unreachable!(),
        }
    }
}

impl TypeRef {}

// UseItem
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseItem {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for UseItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            USE_ITEM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(UseItem { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::AttrsOwner for UseItem {}
impl UseItem {
    pub fn use_tree(&self) -> Option<UseTree> {
        super::child_opt(self)
    }
}

// UseTree
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTree {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for UseTree {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            USE_TREE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(UseTree { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl UseTree {
    pub fn path(&self) -> Option<Path> {
        super::child_opt(self)
    }

    pub fn use_tree_list(&self) -> Option<UseTreeList> {
        super::child_opt(self)
    }

    pub fn alias(&self) -> Option<Alias> {
        super::child_opt(self)
    }
}

// UseTreeList
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTreeList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for UseTreeList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            USE_TREE_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(UseTreeList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl UseTreeList {
    pub fn use_trees(&self) -> impl Iterator<Item = UseTree> {
        super::children(self)
    }
}

// Visibility
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Visibility {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            VISIBILITY => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Visibility { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Visibility {}

// WhereClause
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhereClause {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for WhereClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            WHERE_CLAUSE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(WhereClause { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl WhereClause {
    pub fn predicates(&self) -> impl Iterator<Item = WherePred> {
        super::children(self)
    }
}

// WherePred
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePred {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for WherePred {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            WHERE_PRED => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(WherePred { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::TypeBoundsOwner for WherePred {}
impl WherePred {
    pub fn type_ref(&self) -> Option<TypeRef> {
        super::child_opt(self)
    }
}

// WhileExpr
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for WhileExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            WHILE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(WhileExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ast::LoopBodyOwner for WhileExpr {}
impl WhileExpr {
    pub fn condition(&self) -> Option<Condition> {
        super::child_opt(self)
    }
}

